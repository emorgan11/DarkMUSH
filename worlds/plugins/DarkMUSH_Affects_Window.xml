<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, July 03 2019 .06-pre -->

<muclient>
<plugin
name="DarkMUSH_Affects_Window"
author="Demon"
id="353de94ba6c43260d839e256"
save_state="y"
language="Lua"
purpose="Showing affects in a window"
date_written="2019-07-03 12:04:56"
requires="5.00"
  version="3.6"
>

</plugin>

<!--  Timers  -->

<timers>
  <timer
      script="PlayAllMovieFrames"
      enabled="y"
      second="0.1"
      active_closed="y"
      >

  </timer>
</timers>


<!--  Aliases  -->

<aliases>
    <alias
      regexp="y"
      match="^affects test$"
      enabled="y"
      sequence="100"
	  send_to="12"
      ><send></send>
  </alias>
  <alias
      regexp="y"
      match="^affects window debug$"
      enabled="y"
      sequence="100"
      script="ToggleDebug"
      >
  </alias>
  <alias
  regexp="y"
  match="^spellup$"
  enabled="y"
  sequence="100"
  script="SpellUp"
>
</alias>
<alias
	regexp="y"
	match="^affects snapshot create (.+)$"
	enabled="y"
	sequence="100"
	script="CreateSnapshot"
	>
</alias>
<alias
	regexp="y"
	match="^affects snapshot list$"
	enabled="y"
	sequence="100"
	script="ListSnapshots"
	>
</alias>
<alias
	regexp="y"
	match="^affects snapshot show (.+)$"
	enabled="y"
	sequence="100"
	script="ViewSnapshot"
	>
</alias>
<alias
	regexp="y"
	match="^affects snapshot select (.+)$"
	enabled="y"
	sequence="100"
	script="SelectSnapshot"
	>
</alias>
<alias
	regexp="y"
	match="^affects snapshot update$"
	enabled="y"
	sequence="100"
	script="UpdateSnapshot"
	>
</alias>
<alias
	regexp="y"
	match="^affects snapshot restore ([1-5])$"
	enabled="y"
	sequence="100"
	script="RestoreSnapshot"
	>
</alias>
<alias
	regexp="y"
	match="^affects snapshot backups$"
	enabled="y"
	sequence="100"
	script="ViewBackups"
	>
</alias>
<alias
	regexp="y"
	match="^affects dragon (.+)$"
	enabled="y"
	sequence="100"
	script="SelectDragonForm"
	>
</alias>
<alias
	regexp="y"
	match="^affects help$"
	enabled="y"
	sequence="100"
	script="AffectsHelp"
	>
</alias>
<alias
    match="^affect(|s) hide$"
    enabled="y"
	regexp="y"
    sequence="100"
    script="HideAffects"
    >
</alias>
<alias
    match="^affect(|s) show$"
    enabled="y"
	regexp="y"
    sequence="100"
    script="ShowAffects"
    >
</alias>
</aliases>

<!--  Triggers  -->

<triggers>  
</triggers>

<!--  Script  -->

<script>
  <![CDATA[
	require "movewindow"
	require "mw"
	require "mw_theme_base"
	require "themed_miniwindows"
	require "tprint"
	require "serialize"
	require "gmcphelper"
	require "utility"
	require "json"
	dofile(GetInfo(60) .. "telnet_options.lua")
	dofile(GetInfo(60) .. "darkwiz_colors.lua")
	
	-- Miniwindow State
	local winid = "win_" .. GetPluginID()
	local version = "3.4"
	local hiddenWindow = winid .. "text_background_offscreen"
	local bg_color = "#000000"
	local last_refresh = 0 -- last window refresh
	local pos_x = GetVariable("pos_x") or 100
	local pos_y = GetVariable("pos_y") or 100
	local default_font_size = 8
	local default_font_name = "Lucida Console"
	local font_size = tonumber(GetVariable("font_size")) or default_font_size
	local font_name = GetVariable("font_name") or default_font_name
	local window_visible = true -- always start out with visible window
	local title = "Affects Window"
	local win_height = tonumber(GetVariable("win_height")) or 400
	local win_width = tonumber(GetVariable("win_width")) or 440
	local grip_resize = 10 -- resize grip size
	local timer_color = Theme.BODY_TEXT
	local start_x, start_y = 0, 0
	local image_size = GetVariable("image_size") or 32 -- the width and height of each image
	local text_height = 16 -- 	-- How tall each row of text is (for the timers)
	local text_margin_top = 2 -- The space between the icon and the text
	local show_spell_names = GetVariable("show_spell_names") or "true" -- Toggle for showing spell names
	local spell_name_color = tonumber(GetVariable("spell_name_color")) or ColourNameToRGB("white") -- Color for spell name labels
	
	-- Global Vars
	infos = {} -- this table is filled with the info of every gif
	affects = {}
	active_affects = {} -- holds spell Id of active affects.
	warned_about_missing_files = false
	snapshots = {} -- holds all created snapshots
	selected_snapshot = GetVariable("selected_snapshot") or "default"
	selected_dragon_form = GetVariable("selected_dragon_form") or "acid"
	login_received = false -- flag to ignore affects until comm.login
	connected = false -- flag to track connection state
	pending_removals = {} -- queue of affects to be safely removed
	pending_additions = {} -- queue of affects to be safely added
	MIN_SIZE = 100
	current_time = ""
	path_prefix = "worlds\\plugins\\images\\affects\\"
	path_prefix_64 = "worlds\\plugins\\images\\affects_64x64\\"
	debug = GetVariable("debug") or "false"
	pulse_length = 1
	end_times = {} -- When each spell will run out
	bad_affect = false
	-- In game name to filename map
	
	affect_icons = {
		["68"] = "invis",
		["10"] = "blind",
		["35"] = "curse",
		["103"] = "sleep",
		["374"] = "surge",
		["8"] = "bless", -- bless, detect_invis it bitvector 8, so putting here?
		["hungry"] = "hungry",
		["thirsty"] = "thirsty",
		["94"] = "sanctuary",
		["97"] = "blade_barrier", -- blade barrier
		-------------BITVECTORS BELOW-----------------
		["2"] = "invisible",
		["128"] = "sanctuary",
		["1024"] = "curse",
		["131072"] = "sleep",
		["2048"] = "haste",
		["1"] = "blade_barrier",
		["1073741824"] = "magic_only",
		["33554432"] = "protect_good",
		["16"] = "detect_magic",
		["32"] = "detect_hidden",
		["4"] = "detect_evil",
		["8"] = "detect_invis",
		["256"] = "faerie_fire",
		["512"] = "infrared",
		["8192"] = "evil_protect",
		["16384"] = "slow",
		["32768"] = "sneak",
		["65536"] = "hide",
		["262144"] = "charm",
		["524288"] = "flying",
		["1048576"] = "pass_door",
		["2097152"] = "waterwalk",
		["4194304"] = "nocharm",
		["8388608"] = "noarrow",
		["16777216"] = "nogate",
		["33554432"] = "good_protect",
		["67108864"] = "cover",
		["134217728"] = "nosummon",
		["268435456"] = "waterbreath",
		["536870912"] = "alert",
		-------------NEWLY ADDED AFFECTS WITH NUMBERS----------------
		
		["329"] = "haste",
		["94"] = "sanctuary", -- does THIS fix it? double?
		["149"] = "prayer",
		["100"] = "dragon_form", -- demon, water, fire, lightning, acid, gas all same spell number.
		["375"] = "water_breath",
		["7"] = "armor", -- armor. Order matters or it conflicts with other _armor spells.
		["328"] = "flesh_armor", -- need non-placeholder image
		["377"] = "holy_armor", -- need non-placeholder image
		["105"] = "stone_skin", -- stone_skin
		["316"] = "displacement", -- displacement
		["348"] = "suicidal_attack",
		["324"] = "electricity",
		["350"] = "clarity", --  NOCAST
		["373"] = "flurry", -- flurry NOCAST
		["96"] = "camp", -- camp we will need to not CAST this to re-up it....
		["199"] = "swift", -- swift
		["299"] = "adrenaline_control", -- adrenaline control
		["95"] = "magic_barrier", -- magic barrier
		["356"] = "immunity", -- immunity
		["355"] = "calm", 
		["145"] = "ward", --racial_magic_barrier
		["146"] = "fireshield", 
		["147"] = "frostshield",
		["84"] = "evil_protect", -- evil protection
		["85"] = "good_protect", -- good protection
		["37"] = "detect_all", -- detect all
		["353"] = "daemon", -- daemon
		["8"] = "bless", -- bless
		["25"] = "athelas", -- athelas
		["323"] = "ego_whip", -- ego whip
		["6"] = "conjure_undead", -- animate dead (conjure undead alternative)
		["364"] = "wilderness_aid", -- this is actually 354
		["309"] = "combat_mind", -- combat mind
		["129"] = "alert",
		["334"] = "intellect_fortress",
		["306"] = "blur",
		["325"] = "energy_containment",
		["337"] = "mental_barrier",
		["101"] = "shield", -- Order matters or it picks thought_shield icon.
		["346"] = "thought_shield",
		["344"] = "shadow_decoy",
		["305"] = "biofeedback",
		["75"] = "soul_web",
		["57"] = "fly", -- need non-placeholder image 
		["89"] = "regenerate", -- need non-placeholder image
		["322"] = "ectoplasmic_form",  -- need non-placeholder image
		["370"] = "spirit_thief",
		["46"] = "divine", -- need non-placeholder image
		["383"] = "hold_alignment", -- need non-placeholder image
		["150"] = "mind_focus",
		["411"] = "rotting_flesh", -- need non-placeholder image
		["327"] = "enhanced_strength", -- need non-placeholder image
		["60"] = "giant_strength", -- need non-placeholder image
		["71"] = "gaeas_embrace" -- need non-placeholder image
		--["41"] = detect_magic" -- c 'detect magic'
	}
	
	-- We are using this as a set, these affects should be removed from the window
	-- and not draw a disabled state. Also filtered from buff snapshots
	bad_affects = {
		["10"] = "blind", -- debuff
		["35"] = "curse", -- debuff
		["103"] = "sleep", -- debuff
		["25"] = "athelas", -- athelas. Auto casting a big tree when you're trying to haste feels bad man.
		["323"] = "ego_whip", -- debuff
		["353"] = "daemon", -- HUGE LAG when recast and daemon still alive.
		["6"] = "conjure_undead", -- similar deals.
		["364"] = "wilderness_aid", -- auto-recast and getting something other than nymph feels bad man.
		["374"] = "surge", -- I maintain w/trigger, but it's mana intensive.
		-------------BITVECTORS BELOW-----------------
		["1024"] = "curse",
		["131072"] = "sleep"
	}

	local skills = {
		alert = true,
		clarity = true,
		flurry = true,
		camp = true,
		swift = true,
		fireshield = true,
		frostshield = true,
		ward = true,
		hide = true,
		sneak = true,
		shadow_decoy = true,
	}
	
	
	buttons = {
		-- Priority 1
		{
			name = "Button1",
			tooltip = "Sanctuary",
			text = "Sanctuary",
			send = "c sanc",
			filename = "worlds\\plugins\\images\\affects\\sanctuary_%03i.png",
			disabled_filename = "worlds\\plugins\\images\\affects\\sanctuary_down.png"
		}, -- end of Button 1
		-- Button 2
		{
			name = "Button2",
			tooltip = "Sanctuary",
			text = "Sanctuary",
			send = "c sanc",
			filename = "empty",
			disabled_filename = "worlds\\plugins\\images\\affects\\sanctuary_down.png"
		}, -- end of Button 2
		-- Button 3
		{
			name = "Button3",
			tooltip = "Sanctuary",
			text = "Sanctuary",
			send = "c sanc",
			filename = "empty",
			disabled_filename = "worlds\\plugins\\images\\affects\\sanctuary_down.png"
		}, -- end of Button 3
		-- Button 4
		{
			name = "Button4",
			tooltip = "Sanctuary",
			text = "Sanctuary",
			send = "c sanc",
			filename = "empty",
			disabled_filename = "worlds\\plugins\\images\\affects\\sanctuary_down.png"
		}, -- end of Button 4
		-- Button 5
		{
			name = "Button5",
			tooltip = "Sanctuary",
			text = "Sanctuary",
			send = "c sanc",
			filename = "empty",
			disabled_filename = "worlds\\plugins\\images\\affects\\sanctuary_down.png"
		}, -- end of Button 5
		-- Button 6
		{
			name = "Button6",
			tooltip = "Sanctuary",
			text = "Sanctuary",
			send = "c sanc",
			filename = "empty",
			disabled_filename = "worlds\\plugins\\images\\affects\\sanctuary_down.png"
		}, -- end of Button 6
		-- Button 7
		{
			name = "Button7",
			tooltip = "Sanctuary",
			text = "Sanctuary",
			send = "c sanc",
			filename = "empty",
			disabled_filename = "worlds\\plugins\\images\\affects\\sanctuary_down.png"
		}, -- end of Button 7
		-- Button 8
		{
			name = "Button8",
			tooltip = "Sanctuary",
			text = "Sanctuary",
			send = "c sanc",
			filename = "empty",
			disabled_filename = "worlds\\plugins\\images\\affects\\sanctuary_down.png"
		}, -- end of Button 8
		-- Button 9
		{
			name = "Button9",
			tooltip = "Sanctuary",
			text = "Sanctuary",
			send = "c sanc",
			filename = "empty",
			disabled_filename = "worlds\\plugins\\images\\affects\\sanctuary_down.png"
		}, -- end of Button 9
		-- Button 10
		{
			name = "Button10",
			tooltip = "Sanctuary",
			text = "Sanctuary",
			send = "c sanc",
			filename = "empty",
			disabled_filename = "worlds\\plugins\\images\\affects\\sanctuary_down.png"
		} -- end of Button 10
	
		--> add more priorities here
	} -- end of priorities table
	
	assert(loadstring(GetVariable("saved_buttons") or "saved_buttons = nil"))()
	
	if (saved_buttons) then
		buttons = saved_buttons
	end
	
	function ErrorNote(message)
		ColourNote("Red", "", message)
	end
	
	function DebugNote(message)
		if debug == "true" then
			Note(message)
		end
	end
	
	function ToggleDebug()
		if debug == "false" then
			debug = "true"
			print(debug)
			SetVariable("debug", "true")
			utilprint("$x238Affects window Debug is now $GON$x238.")
		else
			debug = "false"
			print(debug)
			utilprint("$x238Affects window Debug is now $ROFF$x238.")
			SetVariable("debug", "false")
		end
		SaveState()
	end

	function AddAffectTimed(spell, duration)
		DebugNote("AddAffectTimed")
		if (spell ~= nil) then
			DebugNote("Spell: " .. spell)
			if duration ~= nil then
				DebugNote("Duration: " .. duration)
			else
				DebugNote("Duration: PERMANENT")
				duration = -1  -- Set permanent affects to -1 duration
			end
			spell = string.gsub(spell, " ", "_")

			-- Queue this affect for safe addition instead of adding immediately
			table.insert(pending_additions, {spell = spell, duration = duration})
		end -- if
	end -- AddEffectTimed
	
	-- --------------------------------------------------------------------
	-- RemoveAffect (name, line, wildcards)
	-- wildcards[1] must be an active effect
	-- --------------------------------------------------------------------
	function RemoveAffect(name, line, wildcards)
		DebugNote(name)
		name = string.gsub(name, "_", " ")
		DebugNote("RemoveAffect")
		if (name ~= nil) then
			-- Queue this affect for safe removal instead of removing immediately
			table.insert(pending_removals, name)
		else
			DebugNote("Name is nil")
		end
	end
	
	-- Safely process all pending removals without interfering with iterations
	function ProcessPendingRemovals()
		if #pending_removals == 0 then
			return
		end
		
		DebugNote("Processing " .. #pending_removals .. " pending removals")
		
		for _, name in ipairs(pending_removals) do
			local k, v = FindAffectInInfos(name)
			if affect_icons[name] then
				affect = affect_icons[name]:lower()
				if (k >= 0) then
					if (bad_affects[name]) then
						DebugNote("Removing bad affect " .. tostring(k))
						-- Mark for removal from infos table (will be cleaned up below)
						v.markedForRemoval = true
						v.enabled = false
						-- Clear out the pixels of where the removed spell is going to be
						if v and v.x and v.y then
							WindowRectOp(
								winid,
								2,
								v.x,
								v.y,
								v.x + image_size,
								v.y + image_size,
								ColourNameToRGB("bg_color")
							)
							WindowRectOp(
								winid,
								2,
								v.x,
								v.y + image_size + text_margin_top,
								v.x + image_size,
								v.y + image_size + text_margin_top + text_height,
								ColourNameToRGB("bg_color")
							)
							-- Also clear spell name area above if enabled
							if show_spell_names == "true" then
								local spell_name_y = math.max(v.y - text_height, y_off)
								WindowRectOp(
									winid,
									2,
									v.x,
									spell_name_y,
									v.x + image_size,
									spell_name_y + text_height,
									ColourNameToRGB("bg_color")
								)
							end
						end
						bad_affect = true
						DebugNote("BAD AFFECT: ", bad_affect)
					else
						DebugNote("Showing disabled icon for " .. name)
						bad_affect = false
						v.enabled = false
						affect = string.gsub(affect, " ", "_")
						DebugNote(affect)
						DebugNote(DeleteTimer(affect))
					end
				else
					DebugNote("Affect not found in infos for: " .. name)
				end
			else
				DebugNote("affect_icons entry not found for: " .. name)
			end
		end
		
		-- Now safely remove all marked affects from infos table
		local new_infos = {}
		for i, v in ipairs(infos) do
			if not v.markedForRemoval then
				table.insert(new_infos, v)
			end
		end
		infos = new_infos
		
		-- Clear the pending removals queue
		pending_removals = {}
		
		-- Recalculate positions after removals to fill gaps
		if #infos >= 1 then
			local tmp_infos = infos
			infos = {}
			for i, v in ipairs(tmp_infos) do
				local x, y = FindNextPos(image_size + 2)
				v.x = x
				v.y = y
				v.needsRedraw = true
				table.insert(infos, v)
			end
		end
	end
	
	-- Safely process all pending additions without interfering with iterations
	function ProcessPendingAdditions()
		if #pending_additions == 0 then
			return
		end
		
		DebugNote("Processing " .. #pending_additions .. " pending additions")
		
		for _, addition in ipairs(pending_additions) do
			local spell = addition.spell
			local duration = addition.duration
			
			local k, v = FindAffectInInfos(spell)
			if (k == -1 and duration and affect_icons[spell] ~= nil) then
				DebugNote("Adding New Timed Affect")
				-- Use 64x64 folder if image size is 64, otherwise use regular folder
				local folder_path = (image_size == 64) and path_prefix_64 or path_prefix
				PlaceNewGIF(folder_path .. affect_icons[spell], nil, duration, true)
			elseif (duration and affect_icons[spell] ~= nil) then
				v.enabled = true
				v.ticks_left = duration
			end -- if
		end
		
		-- Clear the pending additions queue
		pending_additions = {}
	end
	
	function FindAffectInInfos(name)
		for k, v in pairs(infos) do
			if (affect_icons[name] ~= nil and string.match(v.filename, affect_icons[name]) ~= nil) then
				return k, v
			end
		end
		return -1, -1
	end -- FindAffectInInfos
	
	function GetNumFrames(filename)
		return GetNumFramesHelper(filename, 0)
	end -- GetNumFrames
	
	function GetNumFramesHelper(filename, i)
		old_filename = filename
		filename = string.format(filename, i + 1)
		DebugNote("filename_numframehelp = " .. filename)
		local f = io.open(filename, "r")
		if f ~= nil and i < 1000 then
			io.close(f)
			filename = old_filename
			return GetNumFramesHelper(filename, i + 1)
		else
			DebugNote("f no exists::i=" .. tostring(i))
			return i
		end
	end -- GetNumFrames
	
	-- --------------------------------------------------------------------
	-- PlayGif (info)
	--  info.filename (eg. "/frames/my_Gif_%03i.png" )
	--  info.frames   (eg. 10, if the Gif consists of 10 files)
	--  info.x   - X position on screen
	--  info.y   - Y position on screen
	
	--  Suggested conversion:
	--    ffmpeg -ss "00:30" -i INPUTFILE.mp4 -t 1     -r 10 -s 720x404 frames/my_Gif_%03i.png
	--                ^^^^          ^^^       ^^^^     ^^^^^    ^^^^^^^    ^^^^^^^^^^
	--           Start time      input file  how long   FPS       size      output files
	-- --------------------------------------------------------------------
	function PlayMovie(info)
		movieInfo = info
		if not info then
			return
		end -- if
	
		assert(type(movieInfo) == "table", "Argument to PlayMovie should be a table")
	
		-- see if already in table
		for _, existingInfo in ipairs(infos) do
			if existingInfo.filename == info.filename then
				return
			end
		end
	
		local gotErrors = false
	
		-- load the disabled frame into memory
		if not WindowImageInfo(winid, movieInfo.disabled_filename, 2) then
			local result = WindowLoadImage(winid, movieInfo.disabled_filename, movieInfo.disabled_filename)
		end
	
		-- load each movie frame into memory, if not already done
		for i = 1, movieInfo.frames do
			local filename = string.format(movieInfo.filename, i)
			if not WindowImageInfo(winid, filename, 2) then
				local result = WindowLoadImage(winid, filename, filename)
	
				if result ~= error_code.eOK then
					ErrorNote("Could not open move frame file:")
					ErrorNote("   -> " .. filename)
					ErrorNote("   Reason: " .. error_desc[result])
					gotErrors = true
				end -- if
			end -- if
		end -- for each frame
	
		-- if couldn't do it, discard the movie info
		if gotErrors then
			movieInfo = nil
			return
		end -- if
	
		-- otherwise, start at frame 1
		movieInfo.currentFrame = 1
	
		-- put into table of infos
		table.insert(infos, movieInfo)
	end -- PlayMovie
	
	-- --------------------------------------------------------------------
	-- PlayMovieFrame - show current frame, advance count
	-- --------------------------------------------------------------------
	function PlayMovieFrame(movieInfo)
		-- timing stuff
		timeTaken = timeTaken or 0
		frameCount = frameCount or 0
	
		local startTime = utils.timer()
		local filename
		local errorCode
	
		-- Store the previous image size to detect changes
		prev_image_size = prev_image_size or image_size
	
		local imageWidth = image_size
		local imageHeight = image_size
	
		-- Check if image_size has changed
		if prev_image_size ~= image_size then
			-- Clear the window if image_size has changed
			show_window_no_movie()
			prev_image_size = image_size -- Update the previous size
		end
		-- Draw the correct frame number if the spell is enabled, otherwise draw the disabled image
		if (movieInfo.enabled) then
			filename = string.format(movieInfo.filename, movieInfo.currentFrame)
			errorCode =
				WindowDrawImage(
				winid,
				filename,
				movieInfo.x,
				movieInfo.y,
				movieInfo.x + imageWidth,
				movieInfo.y + imageHeight,
				miniwin.image_stretch
			)
		else
			filename = movieInfo.disabled_filename
	
			-- Because this is a partially transparent image, need to clear out any pixels before drawing
			--TODO: ADD IF STATEMENT BELOW TO ONLY DO THIS WINDOWRECTOP IF ITS A BADEFFECT, OTHERWISE DON'T
			WindowRectOp(
				winid,
				2,
				movieInfo.x,
				movieInfo.y,
				movieInfo.x + imageWidth,
				movieInfo.y + imageHeight,
				ColourNameToRGB("bg_color")
			)
			if WindowInfo("hiddenWindow", 4) == nil then
				DebugNote("No hidden window, creating it now!")
				WindowCreate(hiddenWindow, 0, 0, 0, 0, 12, 3, ColourNameToRGB(bg_color))
			end
	
			-- Here we need to draw the image in a hidden window, resize that window, draw the image transparently, and later draw it stretched
			image_down = filename
	
			if WindowLoadImage(hiddenWindow, image_down, filename) == 0 then
				WindowResize(
					hiddenWindow,
					WindowImageInfo(hiddenWindow, image_down, 2),
					WindowImageInfo(hiddenWindow, image_down, 3),
					ColourNameToRGB(bg_color)
				)
				WindowDrawImageAlpha(hiddenWindow, image_down, 0, 0, 0, 0, 0.3)
				WindowImageFromWindow(winid, image_down, hiddenWindow)
			end
			-- if not string.match(image_down, "%w+_down.png") then
			DebugNote(path_prefix)
			-- Now go ahead and draw the image (used to be alpha, and instead of stretch, 0.5)
			if bad_affect == false then
				--print("drawing image")
				--print(image_down)
				errorCode =
					WindowDrawImage(
					winid,
					image_down,
					movieInfo.x,
					movieInfo.y,
					movieInfo.x + imageWidth,
					movieInfo.y + imageHeight,
					miniwin.image_stretch
				)
				WindowRectOp(
					winid,
					2,
					movieInfo.x,
					movieInfo.y + image_size + text_margin_top,
					movieInfo.x + image_size,
					movieInfo.y + image_size + text_margin_top + text_height,
					ColourNameToRGB("bg_color")
				)
				-- Also clear spell name area above if enabled
				if show_spell_names == "true" then
					local spell_name_y = math.max(movieInfo.y - text_height, y_off)
					WindowRectOp(
						winid,
						2,
						movieInfo.x,
						spell_name_y +3 ,
						movieInfo.x + image_size,
						spell_name_y + text_height,
						ColourNameToRGB("bg_color")
					)
				end
			else
				errorCode = error_code.eOK
				WindowRectOp(
					winid,
					2,
					movieInfo.x,
					movieInfo.y + image_size + text_margin_top,
					movieInfo.x + image_size,
					movieInfo.y + image_size + text_margin_top + text_height,
					ColourNameToRGB("bg_color")
				)
				-- Also clear spell name area above if enabled
				if show_spell_names == "true" then
					local spell_name_y = math.max(movieInfo.y - text_height, y_off)
					WindowRectOp(
						winid,
						2,
						movieInfo.x,
						spell_name_y,
						movieInfo.x + image_size,
						spell_name_y + text_height,
						ColourNameToRGB("bg_color")
					)
				end
				-- Now set the down_image to nothing, so it can draw the next one.
				image_down = 0
			end
		end
		--long WindowDrawImage(BSTR WindowName, BSTR ImageId, long Left, long Top, long Right, long Bottom, short Mode, long SrcLeft, long SrcTop, long SrcRight, long SrcBottom);
	
		if errorCode ~= error_code.eOK then
			ErrorNote("Could not draw image: " .. filename)
		end -- if
		if IsConnected() then -- only count down the timer/redraw when you're connected to the game
			end_time = os.time()
			current_time = movieInfo.ticks_left
			CallPlugin("abc1a0944ae4af7586ce88dc", "BufferedRepaint")
		end
	
		-- next frame
		movieInfo.currentFrame = movieInfo.currentFrame + 1
	
		-- wrap
		if movieInfo.currentFrame > movieInfo.frames then
			movieInfo.currentFrame = 1
		end -- if
	
		-- add up how long we took doing this
		timeTaken = timeTaken + utils.timer() - startTime
		-- and how many times
		frameCount = frameCount + 1
	end -- PlayMovieFrame
	lastRefresh = 0
	
	-- --------------------------------------------------------------------
	-- PlayAllMovieFrames - called by a timer every 1/10 second - calls
	--                      PlayMovieFrame for each movie in the table
	-- --------------------------------------------------------------------
	function PlayAllMovieFrames(timerName)
		for i, j in ipairs(infos) do
			if (infos[i].enabled) then
				-- Only display the timer if the spell is enabled
				local spell_timer = infos[i].ticks_left or 0
	
				local timer_color
				if spell_timer == -1 then
					spell_timer = "PERM"
					timer_color = ColourNameToRGB("fuchsia")
				elseif spell_timer >= 30 then
					timer_color = ColourNameToRGB("lime")
				elseif spell_timer <= 29 and spell_timer >= 10 then
					timer_color = ColourNameToRGB("yellow")
				elseif spell_timer <= 9 then
					timer_color = ColourNameToRGB("red")
				end
				--	    for k, v in pairs (infos) do
				WindowRectOp(
					winid,
					2,
					infos[i].x,
					infos[i].y + image_size + text_margin_top,
					infos[i].x + image_size,
					infos[i].y + image_size + text_margin_top + text_height,
					ColourNameToRGB("bg_color")
				)
	
				-- Center the text using WindowTextWidth to compute text width before hand
				timerWidth = WindowTextWidth(winid, "font", spell_timer)
				-- Calculate centered X position based on image_size
				local centered_x = infos[i].x + (image_size - timerWidth) / 2
				WindowText(
					winid,
					"font",
					spell_timer,
					centered_x,
					infos[i].y + image_size + text_margin_top,
					0,
					0,
					timer_color
				)
			end
		end
	
		for k, v in pairs(infos) do
			-- We need to redraw if any of the following are true:
			-- 1) v.lastDrawState == nil - the frame has never been drawn
			-- 2) v.enabled is true AND frames > 1 - animated affects need constant updates
			-- 3) v.lastDrawState ~= v.enabled - we are switching from enabled to disabled
			-- 4) v.enabled is true AND frames == 1 AND lastDrawState ~= enabled - static affects only on state change
			-- 5) v.needsRedraw is true - force redraw after resize
			local needsRedraw = false
			
			if v.lastDrawState == nil then
				needsRedraw = true
			elseif v.enabled and v.frames > 1 then
				needsRedraw = true -- Always redraw animated affects
			elseif v.lastDrawState ~= v.enabled then
				needsRedraw = true -- State changed
			elseif v.needsRedraw then
				needsRedraw = true -- Force redraw after resize
				v.needsRedraw = false -- Reset the flag
			end
			
			if needsRedraw then
				PlayMovieFrame(v)
			end
	
			v.lastDrawState = v.enabled
		end
		
		-- Now draw spell names AFTER icons have been drawn
		for i, j in ipairs(infos) do
			-- Display spell name above icon if enabled (only for enabled affects)
			if show_spell_names == "true" and infos[i].enabled then
				-- Get spell name from affect_icons table
				local display_name = ""
				
				-- Find which spell this is by checking the filename against affect_icons values
				for spell_id, icon_name in pairs(affect_icons) do
					-- Check if this filename contains this icon name
					if infos[i].filename:find(icon_name) then
						-- Found it! Use the icon name as display name
						display_name = icon_name:gsub("_", " ")
						
						-- Truncate name based on icon size
						if image_size == 32 then
							-- 32x32 mode: show only 4 characters
							if #display_name > 4 then
								display_name = display_name:sub(1, 4)
							end
						else
							-- 64x64 mode: show up to 8 characters
							if #display_name > 8 then
								display_name = display_name:sub(1, 8)
							end
						end
						break
					end
				end
				
				-- Only draw if we have a valid display name
				if display_name ~= "" then
					-- Calculate centered position for spell name
					local nameWidth = WindowTextWidth(winid, "font", display_name)
					local name_centered_x = infos[i].x + (image_size - nameWidth) / 2
					
					-- Draw the spell name above the icon with same margin as timer below
					-- Timer is at: y + image_size + text_margin_top
					-- Spell name should be at: y - text_height (removed text_margin_top to bring it closer)
					-- But don't draw above the window content area
					local spell_name_y = math.max(infos[i].y - text_height, y_off)
					WindowText(
						winid,
						"font",
						display_name,
						name_centered_x,
						spell_name_y,
						0,
						0,
						spell_name_color
					)
				end
			end
		end
		
	-- Process any pending additions and removals at the end of the timer cycle
	ProcessPendingAdditions()
	ProcessPendingRemovals()
end -- PlayAllMovieFrames
	
	---------------------------------------UTILITY FUNCTIONS START-------------------------------------------------
	function swap(table1, table2, name)
		local tmp = table1[name]
		table1[name] = table2[name]
		table2[name] = tmp
	end
	
	function utilprint(string)
		AnsiNote(ColoursToANSI(string))
	end
	
	---------------------------------------UTILITY FUNCTIONS END----------------------------------------------------
	
	-- 16x16 at top, 32x32 below
	-- Offsets due to window border
	x_off = 2
	y_off = 18
	gif_size = image_size
	-- --------------------------------------------------------------------
	-- PlaceNewGif (filename, frames)
	--  filename (eg. "bread" ), expected to be in worlds/plugins/images/affects/filename_%03i.png
	--[[
      NOTE: We must convert all *_down.png images to RGBA format (PNG color type 6) using ImageMagick
      because some engines/tools require a full 4-channel image (red, green, blue, alpha), even if
      the image appears grayscale and has no transparency.

      If the image is stored as Grayscale (color type 0) or Truecolor (color type 2),
      it may be rejected or render incorrectly.

      Use this shell command in the terminal to fix all such files in-place:

      for f in *_down.png; do convert "$f" -alpha set -channel A -evaluate set 100% +channel -define png:color-type=6 "$f"; done

     This forces an opaque alpha channel and saves the PNG as Truecolor+Alpha (RGBA).
    ]]

	-- --------------------------------------------------------------------
	function PlaceNewGIF(filename, frames, duration, enabled)
		local disabled_filename = filename .. "_down.png"
		filename = filename .. "_%03i.png"
		--    print("placing gif")
		DebugNote("PlaceNewGIF")
		DebugNote("filename: " .. filename)
		local rows = math.floor(win_height / gif_size)
		local cols = math.floor(win_width / gif_size)
		local frames = GetNumFrames(filename)
		DebugNote("frames: " .. tostring(frames))
		DebugNote("win_width " .. win_width)
		DebugNote("win_height " .. win_height)
		DebugNote("row " .. rows)
		DebugNote("col " .. cols)
		if (frames ~= 0) then
			num_gifs = #infos
			movieInfo = info
	
			-- Find position
			x, y = FindNextPos(image_size + 2)
			PlayMovie {
				filename = filename,
				disabled_filename = disabled_filename,
				frames = frames,
				x = x,
				y = y,
				enabled = enabled,
				ticks_left = duration
			}
		elseif (not warned_about_missing_files) then
			warned_about_missing_files = true
			ErrorNote("Could not find any frames matching " .. filename)
		end
	
		-- this is used to swap entries in the INFOS table when a filename in the buttons table matches a filename in the infos table
		for i, j in ipairs(infos) do
			if (infos[i].enabled) then
				for n, v in ipairs(buttons) do
					if infos[i].filename == v.filename and (i ~= n) then
						swap(infos[i], infos[n], "filename")
						swap(infos[i], infos[n], "disabled_filename")
						swap(infos[i], infos[n], "enabled")
						swap(infos[i], infos[n], "frames")
						swap(infos[i], infos[n], "lastDrawState")
						swap(infos[i], infos[n], "ticks_left")
						swap(infos[i], infos[n], "currentFrame")
					end
				end
			end
		end
	end
	
	function do_tick()
		-- Count down timers and queue affects for removal
		for k, v in ipairs(infos) do
			if v.enabled and v.ticks_left > -1 then
				v.ticks_left = v.ticks_left - 1
				if v.ticks_left == 0 then
					-- Extract spell name from filename path
					local spell_name = v.filename:match("affects\\(.+)_%d+%.png")
					if spell_name then
						RemoveAffect(spell_name) -- This will queue it safely
					end
				end
			end
		end
		-- ProcessPendingRemovals() will be called at the end of PlayAllMovieFrames
	end
	
	--SHOULD THIS BE IMAGE_SIZE??
	function FindNextPos(size)
		-- Account for spell name text above icons if enabled
		local extra_height = 0
		if show_spell_names == "true" then
			extra_height = text_height
		end
		
		-- Calculate available space including text above and below icons
		-- When spell names are shown: spell_name + icon + margin + timer
		-- When spell names are hidden: icon + margin + timer
		local total_item_height = size + text_height + text_margin_top + extra_height
		
		rows = math.floor(win_height / total_item_height)
		cols = math.floor(win_width / size)
		cur_col = math.floor((#infos) % cols)
		cur_row = math.floor((#infos) / cols) >= 0 and math.floor((#infos) / cols) or 0
		x = x_off + cur_col * size
		y = y_off + cur_row * total_item_height + extra_height
		return x, y
	end

	function HideAffects()
		window_visible = false
		WindowShow(winid, false)
	end
	
	function ShowAffects()
		window_visible = true
		-- Set needsRedraw flag for all infos when showing window
		for k, v in pairs(infos) do
			v.needsRedraw = true
		end
		window(true)
	end
	
	function window(redraw)
		DebugNote("window(" .. tostring(redraw) .. ")")
		if not window_visible then
			return
		end
	
		if redraw then
			WindowDelete("winid")
			WindowCreate(winid, pos_x, pos_y, win_width, win_height, 0, 0, ColourNameToRGB(bg_color))
			WindowPosition(winid, pos_x, pos_y, 0, 2)
			WindowSetZOrder(winid, 201)
			WindowFont(winid, "f1", font_name, font_size, false, false, false, false)
			WindowFont(winid, "b1", font_name, font_size, true, false, false, false)
			WindowFont(winid, "s1", font_name, font_size - 1, false, false, false, false)
			movewindow.install(
				winid,
				6,
				2,
				true,
				nil,
				{mouseup = MouseUp, mousedown = MouseDown, dragmove = LeftClickOnly, dragrelease = LeftClickOnly}
			)
			-- register with the z-order monitor
			CallPlugin("462b665ecb569efbf261422f", "registerMiniwindow", winid)
			movewindow.add_drag_handler(winid, 0, 0, 0, win_height)
			WindowAddHotspot(
				winid,
				"resize",
				win_width - grip_resize,
				win_height - grip_resize,
				win_width,
				win_height,
				"MouseOver",
				"CancelMouseOver",
				"MouseDown",
				"",
				"MouseUp",
				"",
				6,
				0
			)
			WindowDragHandler(winid, "resize", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
		else
			WindowResize(winid, win_width, win_height, ColourNameToRGB(bg_color))
			WindowMoveHotspot(winid, "resize", win_width - grip_resize, win_height - grip_resize, win_width, win_height)
		end
		WindowShow(winid, true)
		show_window()
	end
	
	function show_window()
		WindowRectOp(winid, 2, 2, 1, -2, -2, ColourNameToRGB(bg_color)) -- blank canvas
	
		title = "Affects Window" -- default title
	
		Theme.DrawTitleBar(winid, "f1", title, "center") -- them window title (has to be drawn before border) This is the title bar that says the leader name
		Theme.DrawBorder(winid) -- theme window border
		left, top = 7, 17 -- bar location
		across = 0
		rows = 0
		Theme.AddResizeTag(winid, 2, nil, nil, "MouseDown", "ResizeMoveCallback", "ResizeReleaseCallback") -- resize grip
		PlayAllMovieFrames()
		CallPlugin("abc1a0944ae4af7586ce88dc", "BufferedRepaint")
	end
	
	function show_window_no_movie()
		WindowRectOp(winid, 2, 2, 1, -2, -2, ColourNameToRGB(bg_color)) -- blank canvas
	
		title = "Affects Window" -- default title
	
		Theme.DrawTitleBar(winid, "f1", title, "center") -- them window title (has to be drawn before border) This is the title bar that says the leader name
		Theme.DrawBorder(winid) -- theme window border
		left, top = 7, 17 -- bar location
		across = 0
		rows = 0
		Theme.AddResizeTag(winid, 2, nil, nil, "MouseDown", "ResizeMoveCallback", "ResizeReleaseCallback") -- resize grip
		CallPlugin("abc1a0944ae4af7586ce88dc", "BufferedRepaint")
	end
	
	function ResizeMoveCallback()
		if GetPluginVariable("c293f9e7f04dde889f65cb90", "lock_down_miniwindows") == "1" then
			return
		end
		
		local pos_x, pos_y = WindowInfo(winid, 17), WindowInfo(winid, 18)
		win_width = win_width + pos_x - start_x
		start_x = pos_x
		
		-- Implement minimum width
		if (win_width < MIN_SIZE) then
			win_width = MIN_SIZE
			start_x = WindowInfo(winid, 10) + win_width
		elseif (WindowInfo(winid, 10) + win_width > GetInfo(281)) then
			win_width = GetInfo(281) - WindowInfo(winid, 10)
			start_x = GetInfo(281)
		end
		
		win_height = win_height + pos_y - start_y
		start_y = pos_y
		
		-- Implement minimum height (adjust as needed)
		local min_height = 50  -- Set this to your desired minimum height
		if (win_height < min_height) then
			win_height = min_height
			start_y = WindowInfo(winid, 11) + win_height
		elseif (WindowInfo(winid, 11) + win_height > GetInfo(280)) then
			win_height = GetInfo(280) - WindowInfo(winid, 11)
			start_y = GetInfo(280)
		end
		
		if (os.clock() - last_refresh >= 0.0333) then
			-- Set needsRedraw flag for all infos after resize
			for k, v in pairs(infos) do
				v.needsRedraw = true
			end
			window(false)
			last_refresh = os.clock()
		end
	end
	
	function ResizeReleaseCallback()
		-- Recalculate positions after resize is complete
		if (#infos >= 1) then
			local tmp_infos = infos
			infos = {}
			local warned = false
			for i, v in ipairs(tmp_infos) do
				local x, y = FindNextPos(image_size + 2)
				v.x = x
				v.y = y
				v.needsRedraw = true
				if (not warned and (x > win_width or y > win_height)) then
					warned = true
					Note("Your Affects window is too small to show all the icons, make it bigger!")
				end
				table.insert(infos, v)
			end
		end
		window(true)
		SaveState()
	end
	
	function MouseDown(flags, id)
		if id == "resize" then
			start_x, start_y = WindowInfo(winid, 17), WindowInfo(winid, 18)
		end
		local x, y = WindowInfo(winid, 14), WindowInfo(winid, 15)
	
		slot = -1
		for i, j in ipairs(infos) do
			if x > infos[i].x and x <= (infos[i].x + image_size) and y > infos[i].y and y < (infos[i].y + image_size) then
				clickableX = infos[i].x
				clickableY = infos[i].y
				slot = i
				button = infos[i].filename
				buttonInfo = infos[i].enabled
				duration = infos[i].ticks_left -- Store the duration
			end
		end
	
		if slot == -1 then
			return
		end
	
		-- Highlight the selected slot
		WindowRectOp(
			winid,
			1,
			clickableX - 2,
			clickableY - 2,
			clickableX + image_size + 2,
			clickableY + image_size + 2,
			ColourNameToRGB("red")
		)
	end
	
	function find(tbl, val)
		for k, v in pairs(tbl) do
			if v == val then
				return k
			end
		end
		return nil
	end
	

	function MouseUp(flags, id, win)
		if bit.band(flags, 0x20) ~= 0 then -- right click
			right_click_menu()
		end
		pos_x, pos_y = WindowInfo(winid, 10), WindowInfo(winid, 11)
		SaveState()
	
		if slot == -1 then
			return
		end
	
		WindowRectOp(
			winid,
			1,
			clickableX - 2,
			clickableY - 2,
			clickableX + image_size + 2,
			clickableY + image_size + 2,
			ColourNameToRGB("bg_color")
		)
	
		-- If the affect is not enabled (bitvector is removed), try to recast it
		if buttonInfo ~= true then
			button = button:gsub("%worlds\\plugins\\images\\affects\\", "")
			button = button:gsub("%W%W%w+.png", "")
	
			local spell_key = nil
			for k, v in pairs(affect_icons) do
				if button == v then
					spell_key = k
					break
				end
			end
	
			if spell_key then
				-- Check for other affects with the same name but different numbers
				local permanent_affect_found = false
				local temporary_affect_key = nil
	
				for k, v in pairs(affect_icons) do
					if v == affect_icons[spell_key] then
						for _, info in ipairs(infos) do
							if info.filename:match(affect_icons[k]) then
								if info.ticks_left == -1 then
									permanent_affect_found = true
								else
									temporary_affect_key = k
								end
							end
						end
					end
				end
	
				-- Choose the recast command based on whether it is a skill or a spell.
				local command = nil
				if skills[button] then
					command = button
				else
					if permanent_affect_found and temporary_affect_key then
						command = "c " .. temporary_affect_key
					else
						command = "c " .. spell_key
					end
				end
	
				if command then
					Execute(command)
				end
			end
		end
	end	
	
	
	-- Dynamically populate spelllist based on affect_icons
function populate_spelllist()
    local dynamic_spelllist = {}
    for spell_id, spell_name in pairs(affect_icons) do
        table.insert(dynamic_spelllist, {
            name = spell_name:gsub("_", " "):gsub("^%l", string.upper), -- Capitalize first letter, replace underscores with spaces
            tooltip = spell_name:gsub("_", " "):gsub("^%l", string.upper), -- Tooltip mirrors name
            text = spell_name:gsub("_", " "):gsub("^%l", string.upper), -- Text for the button
            send = "c '" .. spell_name .. "'", -- Placeholder send command
            filename = "worlds\\plugins\\images\\affects\\" .. spell_name .. "_%03i.png",
            disabled_filename = "worlds\\plugins\\images\\affects\\" .. spell_name .. "_down.png"
        })
    end
    return dynamic_spelllist
end

-- Function to display the listbox and update the button with the chosen spell
function choose_spell_for_button(slot)
    -- Dynamically populate spelllist based on affect_icons
    local spelllist = populate_spelllist()
    
    -- Generate the listbox options dynamically from spelllist
    local options = {}
    for _, spell in ipairs(spelllist) do
        table.insert(options, spell.name)
    end
    
    -- Show the listbox and get the user's choice
    local opt = utils.listbox("Choose here from a list of spells", "Pick a spell for your button ...", options)
    if opt == nil or opt == "" then
        return
    end
    
    -- Convert opt to a number (index in spelllist)
    local spell_index = tonumber(opt)
    local chosenspell = spelllist[spell_index]
    local button = buttons[slot]

    -- Replace all of the button's properties with the selected spell
    DebugNote("Setting " .. button.name .. " to " .. chosenspell.name)
    button.name = chosenspell.name
    button.text = chosenspell.text
    button.tooltip = chosenspell.tooltip
    button.send = chosenspell.send
    button.filename = chosenspell.filename
    button.disabled_filename = chosenspell.disabled_filename

    -- Update the infos table based on the button
    for i, info in ipairs(infos) do
        if info.enabled then
            for n, btn in ipairs(buttons) do
                if info.filename == btn.filename and i ~= n then
                    swap(infos[i], infos[n], "filename")
                    swap(infos[i], infos[n], "disabled_filename")
                    swap(infos[i], infos[n], "enabled")
                    swap(infos[i], infos[n], "frames")
                    swap(infos[i], infos[n], "lastDrawState")
                    swap(infos[i], infos[n], "ticks_left")
                    swap(infos[i], infos[n], "currentFrame")
                end
            end
        end
    end
    
    -- Save state and refresh the window
    SaveState()
    window(true)
end

-- Snapshot management functions
function CreateSnapshot(name, line, wildcards)
	local snapshot_name = wildcards[1]
	if snapshot_name == "" then
		utilprint("$RError: Please provide a snapshot name")
		return
	end
	
	-- Load existing snapshots
	local snapshots_data = GetVariable("snapshots") or "{}"
	snapshots = json.decode(snapshots_data)
	
	-- Save current active affects

	snapshots[snapshot_name] = {}
	for k, v in pairs(active_affects) do
		if bad_affects[tostring(k)] == nil then
			snapshots[snapshot_name][k] = v
		else
			print("Ignored spell: " .. bad_affects[tostring(k)])
		end
	end
	
	-- Save snapshots back to variable
	SetVariable("snapshots", json.encode(snapshots))
	utilprint("$GSnapshot '$Y" .. snapshot_name .. "$G' created with " .. table_count(active_affects) .. " affects")
end

function ListSnapshots()
	local snapshots_data = GetVariable("snapshots") or "{}"
	snapshots = json.decode(snapshots_data)
	
	if table_count(snapshots) == 0 then
		utilprint("$x238No snapshots found")
		return
	end
	
	utilprint("$x238" .. string.rep("-", 50))
	utilprint("$WAffects Snapshots:")
	utilprint("$x238" .. string.rep("-", 50))
	
	for name, data in pairs(snapshots) do
		local color = "$x238"
		local marker = ""
		if name == selected_snapshot then
			color = "$G"
			marker = " $Y(selected)"
		end
		utilprint(color .. name .. " $x238- " .. table_count(data) .. " affects" .. marker)
	end
	utilprint("$x238" .. string.rep("-", 50))
end

function ViewSnapshot(name, line, wildcards)
	local snapshot_name = wildcards[1]
	local snapshots_data = GetVariable("snapshots") or "{}"
	snapshots = json.decode(snapshots_data)
	
	if not snapshots[snapshot_name] then
		utilprint("$RSnapshot '" .. snapshot_name .. "' not found")
		return
	end
	
	utilprint("$x238" .. string.rep("-", 50))
	utilprint("$WSnapshot: $Y" .. snapshot_name)
	utilprint("$x238" .. string.rep("-", 50))
	
	for spell_id, _ in pairs(snapshots[snapshot_name]) do
		local spell_name = affect_icons[spell_id] or "unknown"
		local status_color = "$R"
		local status_text = "DOWN"
		
		if active_affects[tonumber(spell_id)] then
			status_color = "$G"
			status_text = "UP"
		end
		
		utilprint("$x238" .. spell_name:gsub("_", " ") .. ": " .. status_color .. status_text)
	end
	utilprint("$x238" .. string.rep("-", 50))
end

function SelectSnapshot(name, line, wildcards)
	local snapshot_name = wildcards[1]
	local snapshots_data = GetVariable("snapshots") or "{}"
	snapshots = json.decode(snapshots_data)
	
	if not snapshots[snapshot_name] then
		utilprint("$RSnapshot '" .. snapshot_name .. "' not found")
		return
	end
	
	selected_snapshot = snapshot_name
	SetVariable("selected_snapshot", selected_snapshot)
	utilprint("$GSelected snapshot: $Y" .. snapshot_name)
end

function SelectDragonForm(name, line, wildcards)
	selected_dragon_form = wildcards[1]
	utilprint("$GSelected Dragon Form: $Y" .. selected_dragon_form)
end

function UpdateSnapshot()
	if not selected_snapshot then
		utilprint("$RNo snapshot selected. Use 'affects snapshot select <name>' first")
		return
	end
	
	-- Load existing snapshots
	local snapshots_data = GetVariable("snapshots") or "{}"
	snapshots = json.decode(snapshots_data)
	
	if not snapshots[selected_snapshot] then
		utilprint("$RSelected snapshot '" .. selected_snapshot .. "' not found")
		return
	end
	
	-- Create backup before updating
	CreateSnapshotBackup(selected_snapshot, snapshots[selected_snapshot])
	
	-- Update selected snapshot with current active affects
	snapshots[selected_snapshot] = {}
	for k, v in pairs(active_affects) do
		if bad_affects[tostring(k)] == nil then
			snapshots[selected_snapshot][k] = v
		else
			print("Ignored spell: " .. bad_affects[tostring(k)])
		end
	end
	
	-- Save snapshots back to variable
	SetVariable("snapshots", json.encode(snapshots))
	utilprint("$GSnapshot '$Y" .. selected_snapshot .. "$G' updated with " .. table_count(active_affects) .. " affects")
end

function CreateSnapshotBackup(snapshot_name, snapshot_data)
	-- Load existing backups
	local backups_data = GetVariable("snapshot_backups") or "{}"
	local backups = json.decode(backups_data)
	
	if not backups[snapshot_name] then
		backups[snapshot_name] = {}
	end
	
	-- Add timestamp to backup
	local backup_entry = {
		data = snapshot_data,
		timestamp = os.time()
	}
	
	-- Insert at beginning of array
	table.insert(backups[snapshot_name], 1, backup_entry)
	
	-- Keep only latest 5 backups
	while #backups[snapshot_name] > 5 do
		table.remove(backups[snapshot_name])
	end
	
	-- Save backups
	SetVariable("snapshot_backups", json.encode(backups))
end

function RestoreSnapshot(name, line, wildcards)
	local backup_number = tonumber(wildcards[1])
	
	if not selected_snapshot then
		utilprint("$RNo snapshot selected. Use 'affects snapshot select <name>' first")
		return
	end
	
	-- Load existing backups
	local backups_data = GetVariable("snapshot_backups") or "{}"
	local backups = json.decode(backups_data)
	
	if not backups[selected_snapshot] or not backups[selected_snapshot][backup_number] then
		utilprint("$RBackup #" .. backup_number .. " not found for snapshot '" .. selected_snapshot .. "'")
		return
	end
	
	-- Load existing snapshots
	local snapshots_data = GetVariable("snapshots") or "{}"
	snapshots = json.decode(snapshots_data)
	
	-- Restore from backup
	snapshots[selected_snapshot] = backups[selected_snapshot][backup_number].data
	
	-- Save snapshots back to variable
	SetVariable("snapshots", json.encode(snapshots))
	
	local backup_time = os.date("%Y-%m-%d %H:%M:%S", backups[selected_snapshot][backup_number].timestamp)
	utilprint("$GRestored snapshot '$Y" .. selected_snapshot .. "$G' from backup #" .. backup_number .. " (" .. backup_time .. ")")
end

function ViewBackups()
	if not selected_snapshot then
		utilprint("$RNo snapshot selected. Use 'affects snapshot select <name>' first")
		return
	end
	
	-- Load existing backups
	local backups_data = GetVariable("snapshot_backups") or "{}"
	local backups = json.decode(backups_data)
	
	if not backups[selected_snapshot] or #backups[selected_snapshot] == 0 then
		utilprint("$x238No backups found for snapshot '$Y" .. selected_snapshot .. "$x238'")
		return
	end
	
	utilprint("$x238" .. string.rep("-", 70))
	utilprint("$WBackups for snapshot: $Y" .. selected_snapshot)
	utilprint("$x238" .. string.rep("-", 70))
	
	local current_time = os.time()
	
	for i, backup in ipairs(backups[selected_snapshot]) do
		local backup_time = os.date("%Y-%m-%d %H:%M:%S", backup.timestamp)
		local time_ago = FormatTimeAgo(current_time - backup.timestamp)
		local affect_count = table_count(backup.data)
		
		utilprint(string.format("$Y#%d $x238- $W%s $x238(%s ago) $x238- $G%d affects", 
			i, backup_time, time_ago, affect_count))
	end
	
	utilprint("$x238" .. string.rep("-", 70))
	utilprint("$x238Use '$Yaffects snapshot restore <number>$x238' to restore a backup")
	utilprint("$x238" .. string.rep("-", 70))
end

function FormatTimeAgo(seconds)
	if seconds < 60 then
		return seconds .. " seconds"
	elseif seconds < 3600 then
		local minutes = math.floor(seconds / 60)
		return minutes .. " minute" .. (minutes == 1 and "" or "s")
	elseif seconds < 86400 then
		local hours = math.floor(seconds / 3600)
		return hours .. " hour" .. (hours == 1 and "" or "s")
	else
		local days = math.floor(seconds / 86400)
		return days .. " day" .. (days == 1 and "" or "s")
	end
end

function table_count(t)
	local count = 0
	for _ in pairs(t) do
		count = count + 1
	end
	return count
end

function AffectsHelp()
	loaded()
end

-- Function to iterate through disabled (fallen) spells and attempt to recast them
function SpellUp()
    local recastCount = 0

    -- Define the skills table
    local skills = {
        alert = true,
        clarity = true,
        flurry = true,
        camp = true,
        swift = true,
        fireshield = true,
        frostshield = true,
		ward = true,
        hide = true,
        sneak = true,
        heighten_senses = true
    }

    -- Use selected snapshot instead of old tracked_affects
    local snapshots_data = GetVariable("snapshots") or "{}"
    local snapshots = json.decode(snapshots_data)
    local affects = snapshots[selected_snapshot] or {}

    -- Loop over all affects
    for spell_key, v in pairs(affects) do
  		local affect = affect_icons[spell_key]
  		if affect and not active_affects[tonumber(spell_key)] then
  			local command = nil
  			if skills[affect] then
  				command = affect
  			else 
				if spell_key == "100" then
					command = "c " .. spell_key .. " " .. selected_dragon_form
				else
					command = "c " .. spell_key
				end
  			end
  			Execute(command)
      	recastCount = recastCount + 1
  		end
    end
	    
    if recastCount == 0 then
        utilprint("$RNo spells to re-up.")
    else
        utilprint("$GRecasted " .. recastCount .. " spells.")
    end
end





function right_click_menu(buttonIndex)
    local x, y = WindowInfo(winid, 14), WindowInfo(winid, 15)
    
    -- Always display these options
    local str = "!"
    str = str .. "Change Font"
    str = str .. "|-|Bring to Front"
    str = str .. "|-|Send to Back"
    str = str .. "|-|Set images to small (32)"
    str = str .. "|-|Set images to large (64)"
    str = str .. "|-|Toggle spell names"
    str = str .. "|-|Change spell name color"
    
    -- Only add the "Choose Spell" option if in a valid button zone
    if slot ~= -1 and buttons[slot] then
        str = str .. "|-|Choose Spell"
    end
    
    local opt = WindowMenu(winid, x, y, str)
    if opt == "" then
        -- Menu was cancelled, still need to refresh the window
        -- Force all affects to redraw
        for k, v in pairs(infos) do
            v.needsRedraw = true
        end
        window(true)
        return
    end
    
    opt = tonumber(opt)

    -- Handle the selected option
    if opt == 1 then
        -- Change font
        local wanted_font = utils.fontpicker(font_name, font_size)
        if wanted_font then
            font_name = wanted_font.name
            font_size = wanted_font.size
            -- Update the font in the window
            WindowFont(winid, "font", font_name, font_size, false, false, false, false)
            -- Set needsRedraw flag for all infos when changing font
            for k, v in pairs(infos) do
                v.needsRedraw = true
            end
        end
    elseif opt == 2 then
        CallPlugin("462b665ecb569efbf261422f", "boostMe", winid)
    elseif opt == 3 then
        CallPlugin("462b665ecb569efbf261422f", "dropMe", winid)
    elseif opt == 4 then
        image_size = 32
        SetVariable("image_size", image_size)
        -- Clear the entire window first to remove any remnants
        WindowRectOp(winid, 2, 0, 0, win_width, win_height, ColourNameToRGB("bg_color"))
        -- Force recalculation of all positions since icon size changed
        local tmp_infos = infos
        infos = {}
        for i, v in ipairs(tmp_infos) do
            local x, y = FindNextPos(image_size + 2)
            v.x = x
            v.y = y
            v.needsRedraw = true
            table.insert(infos, v)
        end
    elseif opt == 5 then
        image_size = 64
        SetVariable("image_size", image_size)
        -- Clear the entire window first to remove any remnants
        WindowRectOp(winid, 2, 0, 0, win_width, win_height, ColourNameToRGB("bg_color"))
        -- Force recalculation of all positions since icon size changed
        local tmp_infos = infos
        infos = {}
        for i, v in ipairs(tmp_infos) do
            local x, y = FindNextPos(image_size + 2)
            v.x = x
            v.y = y
            v.needsRedraw = true
            table.insert(infos, v)
        end
    elseif opt == 6 then
        -- Toggle spell name display
        if show_spell_names == "true" then
            show_spell_names = "false"
        else
            show_spell_names = "true"
        end
        SetVariable("show_spell_names", show_spell_names)
        
        -- Clear the entire window first to remove any remnants
        WindowRectOp(winid, 2, 0, 0, win_width, win_height, ColourNameToRGB("bg_color"))
        
        -- Force recalculation of all positions since spacing changes with spell names
        local tmp_infos = infos
        infos = {}
        for i, v in ipairs(tmp_infos) do
            local x, y = FindNextPos(image_size + 2)
            v.x = x
            v.y = y
            v.needsRedraw = true
            table.insert(infos, v)
        end
    elseif opt == 7 then
        -- Change spell name color
        local newColor = PickColour(spell_name_color)
        if newColor ~= -1 then
            spell_name_color = newColor
            SetVariable("spell_name_color", tostring(spell_name_color))
        end
        -- Force redraw of all infos whether color was changed or cancelled
        for k, v in pairs(infos) do
            v.needsRedraw = true
        end
    elseif opt == 8 and slot ~= -1 and buttons[slot] then
        -- This option is only possible if "Choose Spell" was added, which means we're in a valid button zone
        choose_spell_for_button(slot)
    end

    -- Always force redraw of all affects before refreshing window
    for k, v in pairs(infos) do
        v.needsRedraw = true
    end
    
    SaveState()
    window(true)
end

	
	
	function CancelMouseOver(flags, id)
	end
	
	function CancelMouseDown(flags, id)
	end
	
	function SaveState()
		SetVariable("pos_x", pos_x)
		SetVariable("pos_y", pos_y)
		SetVariable("win_width", win_width)
		SetVariable("win_height", win_height)
		SetVariable("debug", tostring(debug))
		SetVariable("prompt_gag", tostring(prompt_gag))
		SetVariable("show_spell_names", show_spell_names)
		SetVariable("spell_name_color", tostring(spell_name_color))
		SetVariable("font_name", font_name)
		SetVariable("font_size", tostring(font_size))
		SetVariable("selected_dragon_form", selected_dragon_form)
	end
	
	function loaded()
		utilprint("$x238------------------------------------------------------------------------------------------")
		utilprint("$WPlugin Name  : $RG$Yr$Ga$Cp$Bh$Mi$mc$Ra$Yl $x238Affects Window")
		utilprint("$WAuthor       : $x238Demon")
		utilprint("$WVersion      : $G" .. version)
		utilprint("$x238------------------------------------------------------------------------------------------")
		utilprint("")
		utilprint("                       $x220Graphical $x220Affects Window Commands                            ")
		utilprint("$x238------------------------------------------------------------------------------------------")
		utilprint("")
		utilprint("$Y affects snapshot create <name>      $R-->$W Creates a snapshot of current active affects")
		utilprint("$Y affects snapshot list               $R-->$W Shows all snapshots with affect counts")
		utilprint("$Y affects snapshot show <name>        $R-->$W Shows affects in a snapshot with status")
		utilprint("$Y affects snapshot select <name>      $R-->$W Selects which snapshot to use for spellup")
		utilprint("$Y affects snapshot update             $R-->$W Updates selected snapshot with current affects")
		utilprint("$Y affects snapshot backups            $R-->$W Views backup history for selected snapshot")
		utilprint("$Y affects snapshot restore <1-5>      $R-->$W Restores snapshot from backup (1=latest)")
		utilprint("$Y affects dragon <name>               $R-->$W Selects which dragon form to use when using spellup")
		utilprint("$Y affects show                        $R-->$W Shows the affects window")
		utilprint("$Y affects hide                        $R-->$W Hides the affects window")
		utilprint("$Y affects help                        $R-->$W Displays this help page")
		utilprint("$Y spellup                             $R-->$W Recasts fallen spells from selected snapshot")
		--utilprint("$Y affects window debug                $R-->$W Toggles debug mode on/off")
		utilprint("")
		utilprint("$W                            $x220Window Controls")
		utilprint("$x238------------------------------------------------------------------------------------------")
		utilprint("$Y Left Click on Icon                  $R-->$W Attempts to recast the spell/skill")
		utilprint("$Y Right Click on Window               $R-->$W Opens context menu with options:")
		utilprint("$Y   - Bring to Front/Send to Back     $R-->$W Changes window layering")
		utilprint("$Y   - Set images to small (32)        $R-->$W Sets icon size to 32x32 pixels")
		utilprint("$Y   - Set images to large (64)        $R-->$W Sets icon size to 64x64 pixels")
		utilprint("$Y   - Choose Spell (in icon area)     $R-->$W Assigns spell to button slot")
		utilprint("")
		utilprint("$x238------------------------------------------------------------------------------------------")
		utilprint("")
	end
	
	function OnPluginInstall()
		WindowFont(winid, "font", font_name, font_size, false, false, false, false, 0)
		window(true)
	
		DoAfterSpecial(.2, "loaded()", 12)
		
		-- Check if we're connected and request affects if so
		if IsConnected() then
			connected = true
			login_received = true
			Execute("aff")
		end
	end
	
	function OnPluginBroadcast(msg, id, name, text)
		-- Look for GMCP handler.
		if (id == "3e7dedbe37e44942dd46d264") then
			if (text == "affon") then
				-- Ignore affects until comm.login is received
				if not login_received then
					return
				end
				res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264", "gmcpval", "affon")
				luastmt = "gmcpdata = " .. gmcparg
				assert(loadstring(luastmt or ""))()
				spell = tonumber(gmcpval("spell"))
				duration = tonumber(gmcpval("duration"))
				AddAffectTimed(spell, duration)
				active_affects[spell] = true
			--	cast_queue()
			end
			if (text == "affoff") then
				-- Ignore affects until comm.login is received
				if not login_received then
					return
				end
				res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264", "gmcpval", "affoff")
				luastmt = "gmcpdata = " .. gmcparg
				assert(loadstring(luastmt or ""))()
				spell = tonumber(gmcpval("spell"))
				RemoveAffect(spell)
				active_affects[spell] = nil
			end
			if text == "comm.tick" then
				res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264", "gmcpval", "comm.tick")
				do_tick()
			end
			if text == "comm.login" then
				connected = true
				login_received = true
				Execute("aff")
			end
		end
	end
	
	function OnPluginEnable()
		window(true)
	end
	
	function OnPluginDisable()
		WindowDelete(winid)
		SaveState()
	end
	
	function OnPluginClose()
		WindowDelete(winid)
	end
	
	function OnPluginConnect()
		DebugNote("OnPluginConnect")
	end
	
	function OnPluginSaveState()
		SaveState()
	end
	
	function OnPluginWorldSave()
		SaveState()
	end
	
	function OnPluginDisconnect()
		-- Clear all affects data on disconnect and reset flags
		infos = {}
		active_affects = {}
		pending_additions = {}
		pending_removals = {}
		login_received = false
		connected = false
		
		-- Clear the visual window content to prevent overlap on reconnect
		if window_visible then
			show_window_no_movie()
		end
		
		SaveState()
	end
	
	function OnPluginListChanged()
		SaveState()
	end
	
	window(true)
	
    ]]>
</script>

</muclient>
